CONSIDERACIONES CHATGPT:
1. Parsers y tokens.
	Dividir el input del user como ls -l | grep txt > out.txt
	en tokens y luego construir una estructura para interpretarlo
2. Redirección de pipes.
	Entender como funcion dup2, pipe, fork y execve
3. Builtins
	Comandos como cd, exit, export, pwd hay que implementarlos
	sin execve. Mejor hacerlos aparte en ficheros c. y probar
4. Variables de entorno.
	Usar envp del main, y gestionar nuestras propias variables (Manuel,
	puso dos que no se podian destruir) con export y unset
5. Señales. 
	Control+c, control+D, control+\ tienen que comportarse como Bash.
6. Sin errores de valgrind. Norminette y sanitizer

FUNCIONES AUTORIZADAS:

				************ FUNCIONES DE PROMPT **************

readline(const char *prompt) #include <readline/readline.h> #include <readline/history.h>
	Muestra un prompt ("terminal$ ") y esperar que el usuario
	escriba algo.
	Devuelve lo que escribió el user como un char * que se ha de liberar
	con un free(). Es como un read pero con ventajas:
	1. soporta historial (fechas ↑ ↓)
	2. soporta edición de linea para borrar con backspace
	3. parece una terminal real.
	ej:
		char *input;

		input = readline("minishell$ ");
		if (input){
			//usar input
			free(input);
		}
		else{
			//esto ocurre si se pulsa Ctrl+D
			printf("exit\n");
			exit(0);
		}

rl_clear_history()
	Borra el historial de comandos guardado por readline.
	Cada vez que se usa readline, SI SE GUARDA el comando con add_history(input)
	se va acumulando en una lista. rl_clear_history() borra esa lista. Si no se
	usa add_history(input) no hay nada que borrar.
	DEBE SER PUESTO AL FINAL DEL PROGRAMA PARA NO HABER LEAKS DE MEMORIA.

rl_on_new_line(void)
	Le dice a realine que estamos comenzando una nueva linea de entrada.
	Útil cuando se usan señales como Ctrl+c y necesito que readline se reajuste
	para mostrar el prompt bien en la siguiente linea.
	rl_replace_line("", 0) //borra la linea actual
	rl_on_new_line(); //le dice a readline que empieze una nueva linea
	rl_redisplay(); Muéstra el prompt de nuevo.
	Estas 3 lineas de arriba se hacen por ejemplo si se hace Ctrl+c para que no se
	quede el prompt a medias y quede limpio
	Es decir: "ey readline!! vamos a empezar una nueva linea!" No imprime nada. Solo informa
	a readline.

rl_redisplay(void)
	redibuja el prompt y el contenido actual de la linea de entrada. Sin rl_redisplay()
	no vuelve a mostrar el prompt visualmente aunque internamente esté listo para escribir.
	
rl_replace_line(const char *text, int clear_undo)
	reemplaza el contenido actual de la linea de entrada donde el user está escribiendo
	por el texto que se le pase
	rl_replace_line("", 0); //borra la linea actual reemplazando con cadena vacia.
	clear_undo: indica si se debe limpiar el historial de desacer dicha linea (mejor poner 0)
	Se usa con señal Ctrl+c ya que si no se hace nada puede dejar carácteres escritos en la linea
	void handle_sigint(int sig){ //cuando se pulsa Ctrl+c.
		(void)sig;
		write(1, "\n", 1);
		rl_replace_line("", 0); //limpia la linea actual
		rl_on_new_line(); //prepara nueva linea
		rl_redisplay(); //muestra el prompt limpio.
	}
	readline maneja automáticamente el uso de delete o backspace.

add_history(const char *line)
	añade una linea al historial de comandos de readline para luego navegar en el 
	histórico con las flechas ↑ ↓
	char *input = readline("minishel$ ");
	if (input && *input){ //se hace para no guardar entradas en blanco.
		add_history(input);
		free(input); //si no se hace se produce leak.
	}
	este historia se guarda en memoria. NO archivo o sea que se pierde al cerrar minishell
	cada add_history COPIA INTERNAMENTE La linea asi que al final del programa hay que
	rl_clear_history(); para no tener leaks.
	En el comportamiento original de bash, history no duplica comandos repetidos. Solo
	los coloca abajo. Esto lo hace internamente add_history. NO hace falta hacer nada.

					************** FUNCIONES NORMALES **************

access (#include <unistd.h>)
	int access(const char *pathname, int mode)
	comprueba los permisos de acceso a un archivo o directorio
	mode:
		R_OK: ¿Se puede leer?
		W_OK: ¿Se puede Escribir?
		X_OK: ¿Se puede ejecutar?
		F_OK: ¿Existe el Archivo?
	retorna:
		0	-> si los permisos son correctos
		-1	-> si ocurre un error, y se establece errno para indicar el error.

	int main(){
			if(access(filename, F_OK) == 0)
				printf("el archivo existe");}
	IMPORTANTE:	No siempre es confiable en sistemas concurrentes (procesos e hilos)
				por lo que hay que hacer mutex. Mejor hacerlo asi:
				int fd = open("archivo", O_RDONLY);
				if (fd == -1){
					if (errno == EACCES)
						write(2, "Permiso denegado\n", 18);
					else if (errno == ENOENT)
						write(2, "Archivo no existe\n", 19); 
					else
						perror("open")
				}


						*************** PROCESOS **************

fork() (#include <unistd.h>)
	pid_t pid = fork();
	devuelve:
		> 0		-> estamos en el proceso padre y PID es el del hijo.
		== 0	-> estamos en el hijo
		< 0		-> error en el fork.
	Cada vez que ejecutemos un comando externo (ls, echo...) necesitamos:
		1. crear un hijo con fork()
		2. En el hijo ejecutar execve() y si falla exit(1);
		3. En el padre esperar con wait() o waitpid(pid, NULL, 0);
		Asi la shell sigue activa mientras el hijo corre el comando
	int main(){
		printf("Antes del fork\n");
		pid_t pid = fork();
		if (pid == 0)
			printf("Soy el hijo\n");
		else if (pid > 0){
			printf("Soy el padre\n");
			wait(NULL); //para que no se quede ZOMBI el hijo}
		return (0);}
	Un proceso ZOMBI no son leaks, pero si ocupa espacio en la tabla de procesos
	del kernel que es limitada. Si se acumulan no se podrian generar nuevos procesos
	IMPORTANTE ulimit -u 100 limita a 100 procesos x usuario. PROTEGERSE!!!
	pid_t pid = fork();
	if (pid < 0)
	{
	    perror("fork");
		//LIBERAR TODO!!
	    return (1);
	}

wait(int *status) y pid_t waitpid(pid_t pid, int *status, int options)
	Los dos esperan a que terminen los procesos hijos. Pero el wait espera a que
	termine cualquiera de los que haya, y el waitpid uno en específico.
	en waitpid:
		si pid == -1 es igual que wait() espera a que cualquier hijo termine
		pid > 0 -> espera al hijo exacto
		options == 0 -> comportamiento por defecto (bloqueante)
		options == WNOHANG no espera si no hay hijo terminado (devuelve 0)
	status es donde se guarda un valor codificado, COMO TERMINÓ el proceso:
		WIFEXITED(status) -> ¿Terminó con exit()?
		WEXITSTATUS(status) -> Si salió con exit(), te da dicho valor de exit()
		WIFSIGNALED(status) -> ¿Murió por una señal?
		WTERMSIG(status) -> si murió por señal, cual es la que lo mató.
		int status;
		pid_t pid = wait(&status);
		if (WIFEXITED(status))
			printf("Hijo termino con codigo %d\n", WEXITSTATUS(status));
		Si se el pasa con NULL, no interesa dicha info.

wait3(int *status, int options, struct rusage *rusage)
	lo mismo que wait, pero te da estadisticas (cpu, memoria) del hijo terminado a
	traves del puntero rusage

wait4(pid_t pid, int *status, int options, struct rusage *rusage)
	igual que waitpid(), pero con estadísticas rusage.
	La estructura rusage contiene datos como tiempo de CPU, numero de paginas de memoria
	usada, swaps, señales recibidas... NO ES NECESARIO PARA LA MINISHELL


					************** SEÑALES **************

kill -> int kill(pid_t pid, int sig)
	Envia la señal sig al proceso pid.
	pid > 0 -> envia a ese pid
	pid = 0 -> se envia a todos los procesos en mismo grupo de procesos
	pid < 0 -> señal enviada a todos lo procesos a los que el user tiene permiso
	retorna: 0 -> exito
			-1 -> error.

signal -> void (*signal(int signum, void(*handler)(int)))(int); #include <signal.h>
	Más sencilla que sigaction, sirve para darle una funcion (handler), a la señal
	recibida. Tienes menos control

sigaction -> int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
	struct sigaction	sa;
	sa.sa_flags = SA_SIGINFO; //al definir este flag entra automaticamente la funcion sa_sigaction
	//definida en la estructura sigaction (*act). Si no entraria sa_handler que seria como un signal()
	sa.sa_sigaction = process_header_msg;
	sigaction(B_0, &sa, NULL);
	-> procesa la funcion: void	process_header_msg(int signal, siginfo_t *info, void *context)

	para pasarle una variable a dicho process_header_msg, como no puede recibir otros parametros
	por que ya esta predefinida la función (se le puede cambiar el nombre pero no su prototipo)
	normalmente se pasa una variable global... PERO CREO QUE SE PUEDE HACER ESTO:
	struct sigaction sa;
	sa.sa_flags = SA_SIGINFO;
	sa.sa_sigaction = process_header_msg;
	sa.sa_mask = 0;
	// Aquí pasamos `g_server` como `context`
	t_server *g_server_ptr = g_server; // Siendo t_server *g_server;
	sigaction(B_0, &sa, (struct sigaction *)&g_server_ptr); //se le pasa como el *context

sigaddset -> int sigaddset(sigset_t *set, int signum)
	añade la señal signum al congunto set.
	devuelve: 	0 -> si va bien
				-1 -> si falla

sigemptyset -> int siemptyset(sigset_t *set)
	Borra el contenido de señales de un conjunto
	
	struct sigaction sa;
    // 1. Ignorar SIGINT. para eliminar el uso de control + c
    sa.sa_handler = SIG_IGN;  // SIG_IGN es lo que pasar para ignorar la señal. Si no, le pondríamos el nombre de la funcion handler
    sigemptyset(&sa.sa_mask);  // No bloqueamos ninguna señal.Eliminamos todas las señales de las mascaras. Si no lo hacemos puede tener basura. Es como asignar NULL a una variable puntero creada.
    sa.sa_flags = 0; //pilla sa_handler y no sa_sigaction que seria con SA_SIGINFO mas valores de flag:

	//	SA_SIGINFO	 -> usa sa_sigaction
	//	SA_RESTART	 -> Llamadas bloqueantes como read() se reintentan si son interrumpidas por una señal
	//	SA_NOCLDSTOP -> Evita que SIGCHLD se envie cuando un hijo se detiene o continua
	//	SA_NOCLDWAIT -> No deja procesos zombi de hijos. Los elimina
	//	SA_NODEFER   -> Permite que la misma señal se reciba mientras se está manejando.
	//	SA_RESETHAND -> Despues de manejar la señal una vez se restaura su comportamiento por defecto.
	// 	Se pueden usar varios como: sa.sa_flags = SA_SIGINFO | SA_RESTART;
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("Error al configurar la acción para SIGINT");
        return 1;}
	// 2. Restaurar el manejador original de SIGINT
    sa.sa_handler = handle_sigint;  // Establecemos el manejador original para SIGINT
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("Error al restaurar la acción para SIGINT");
        return 1;}


		************** RESERVA DE MEMORIA Y LIBERACION **************

free()
	para liberar los ft_callocs

malloc()
	Usaremos ft_calloc()


			************** FUNCIONES ABRIR ARCHIVOS **************

open()
	abrir archivos (fd)

read(fd, buffer, tamaño buffer)
	lee del fd y lo mete en el buffer.

close(fd)
	cerrar el archivo abierto


				************** FUNCIONES ESCRIBIR **************

printf()
	Para imprimir

write()
	para imprimir

